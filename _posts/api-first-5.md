---
layout:        post
title:         "Building an API-driven software: Typscript"
date:          "2019-11-27"
categories:    blog
excerpt:       ""
preview:       /assets/img/api-first-5.jpg
fbimage:       /assets/img/api-first-5.png
twitterimage:  /assets/img/api-first-5.png
googleimage:   /assets/img/api-first-5.png
twitter_card:  summary_large_image
tags:          [Development, Clean code, Typescript, ReactJS]
sharing:
  twitter:  "API-driven App: Building a frontend!"
  facebook: "API-driven App: Building a frontend!"
  linkedin: "API-driven App: Building a frontend!"
  patreon:  "API-driven App: Building a frontend!"
  discord:  "@everyone API-driven App: implementing OpenAPI / Swagger!"
---

In our [previous episode](/blog/api-first-4) we have implemented OpenAPI. Now it's time to take this theoretical 
advantage and put into practice: we will generate a Typescript client library, and a provisional
ReactJS frontend application. Of course, this will not be our final admin interface, but for now, this will do nicely.

## Preparing the environment

In order to use Typescript you will need to install [NodeJS](https://nodejs.org/en/) and the
[yarn package manager](https://yarnpkg.com/lang/en/).

## Installing React

Once this is done, let's install React:

```
yarn create react-app src/frontend --template typescript
```

Next, as the prompt tells us, let's start the app:

```
cd src/frontend
yarn start
```

This should start the dev server on [http://localhost:3000](http://localhost:3000).

## Generating the client library

Now that we have our basic typescript/react setup done, let's turn our attention to the OpenAPI bit. Our goal, as I 
previously mentioned, is to generate a full client library from the OpenAPI document generated by Swagger.

To do this we first start our backend as we did previously. We will do this by adding a dependency to our frontend
module by running the following in our `src/frontend` directory.

```
yarn add --dev @openapitools/openapi-generator-cli
```

The next step is to run, still in the `src/frontend` folder, the code generation that downloads the API description from
the backend running on port 8000 and generates us a Typescript client library:

```
openapi-generator generate \
    -g typescript-fetch \
    -i http://localhost:8080/v2/api-docs \
    -p npmName=blog-client,npmVersion=1.0.0,snapshot=true,useSingleRequestParameter=false,withInterfaces=true,typescriptThreePlus=true,supportsES6=true,ensureUniqueParams=false
```

Yes, this is a bit of a mouth full, but this will generate a client library in `src/frontend/lib/blog-client`. Now, 
normally, if your API was public, you would want to publish this to NPM, but since our aim is to only write a frontend,
we will dispense with publishing the client library. Instead, let's add this folder as a source for a module:

```
yarn add file:./lib/blog-client
```

Now, you need to re-generate and reinstall the client library every time the API changes, so let's create a little
script in the `package.json` file in the `scripts` section to make the process easier:

```json
{
//...
  "scripts": {
    //...
    "generate": "cd lib/blog-client && rm -rf dist && openapi-generator generate -g typescript-fetch -i http://localhost:8080/v2/api-docs -p npmName=blog-client,npmVersion=1.0.0,snapshot=true,useSingleRequestParameter=false,withInterfaces=true,typescriptThreePlus=true,supportsES6=true,ensureUniqueParams=false && rm -rf node_modules/blog-client && yarn install --check-files && yarn run build",
    //...
  },
//...
}
```

I know, this one is a bit long too, but it will enable us to run `yarn generate` to regenerate the client library
sources at any time. (Note that this script wll not work in its current form on Windows.)

## Integrating the client library

The next step, and I strongly recommend an IDE like IntelliJ IDEA with the Typescript plugin for this, is to 
create the abstraction layer in the frontend code.

We will create this extra abstraction layer because while our generated code might change, we do not want our app to 
change because of that.

For our abstraction layer we will create a file called `src/frontend/src/BlogClient.ts`. While you are creating
this file please notice how IntelliJ automatically gives you full code completion for the client library. This is
because our OpenAPI type defintions have helped the generator to create full Typescript definitions.

```typescript
import {BlogPost, BlogPostsApi} from "blog-client";

export default class BlogClient {
    constructor(private readonly api: BlogPostsApi) {
    }

    public async create(slug: string, title: string, content: string): Promise<BlogPost> {
        return await this.api.create({
            slug: slug,
            title: title,
            content: content
        })
    }
    
    public async get(slug: string): Promise<BlogPost> {
        return await this.api.get(slug);
    }
    
    public async update(slug: string, title: string, content: string): Promise<BlogPost> {
        return await this.api.update(slug, {
            title: title,
            content: content
        })
    }
    
    public async delete(slug: string) {
        return await this.api._delete(slug);
    }
}
```

While this might seem like a pointless excercise in creating an abstraction, please let me reiterate, that when the
generated code changes, this might break your app. If you use an abstraction like this, it will break in only one place.

Please note that I have not abstracted away the `BlogPost` object, because I consider it a business entity and if its
structure changes, I will have to update a bunch of code anyway.  